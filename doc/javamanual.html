<!-- Copyright 2011, UCAR/Unidata  -->
<!-- See the LICENSE.txt file for more information. -->
<html>
<body>
<center>

<h1>Unidata AST Translation System<br>
Java Language User Manual</h1>
<h3>Draft: 09/29/2011<br>
Last Revised: 09/29/2011</h3>
<h3>Author: Dennis Heimbigner<br>
dmh@ucar.edu<br>
Unidata<br>
Copyright 2011, UCAR</h3>
</center>

<h2><u>Introduction</u></h2>
This document describes how to use the
Java language code generated by the Unidata AST compiler.
<p>
Currently, the compiler can generate code for
either the C language or the Java language.
Using the C code is described in the
"cmanual.html" file.

<h2><u>Compiler Output</u></h2>
Given a protobuf file name
<i>X.proto</i>
the ast compiler will generate a single Java code file
<i>X.java</i>
<p>
The file will contain a single class named
either "X" or named as defined by the "java_class"
option.
All messages in the file X.proto will be translated
to static public classes inside the top-level class.
If those messages themselves define nested classes,
the they will be defined inside the corresponding
translated message class.  This means that the natural
naming mechanism "X.y.z" is supported.
<p>
Enumeration declarations are also inserted in the appropriate
class in the output file to correspond with the location
of the enumeration in the .proto file.
<p>
In addition, and for every message declaration,
<i>message M {...}</i> for example,
the file will contain methods
to serialize an instance of a message M (M.write()),
to deserialize an instance of a message M (M m = M.read()),
and
to compute the run-time size of an instance of a message M (M.getSize()).
<p>
<h3>Example</h3>
Assume we have the following message declaration
inside a file name <i>Main</i>.
<pre>
message Msg {
    required float field1 = 1;
    optional uint64 field2 = 2;
    repeated int32 field3 = 3;
}
</pre>
This will generate the following output.
<pre>
public class Main
{
static public class Msg
{
    float field1;
    Long field2;
    Integer[] field3;
};
</pre>
It will also generate the following three methods
<ul>
<li>public void write() throws ASTException
<li>public Msg read() throws ASTException
<li>public int getSize()
</ul>
<p>
The <i>getSize</i> method is necessary because the actual size
of each <i>Msg</i> object may vary at run-time.
<p>
Protobuf enumeration declarations are also translated in the
more or less obvious way. So given the protobuf enumeration
<pre>
enum Testenum {
    ECON1 = 1;
    ECON2 = 2;
    ECON3 = 3;
    ECON4 = 4;
    ECON5 = 5;
    ECON6 = 6;
}
</pre>
it will be translated to the following Java enumeration declaration.
<pre>
public enum Testenum {
    ECON1(1),
    ECON2(2),
    ECON3(3),
    ECON4(4),
    ECON5(5),
    ECON6(6);

    private int value;
    static public int getValue() {return value;}
    public Testenum(int value) {this.value = value;}
    public Testenum toEnum(int i)
    {
	switch (i) {
	case 1: return Testenum.ECON1;
	case 2: return Testenum.ECON2;
	case 3: return Testenum.ECON3;
	case 4: return Testenum.ECON4;
	case 5: return Testenum.ECON5;
	case 6: return Testenum.ECON6;
	default: return null;
    }
} Testenum;
</pre>
The toEnum code is provided to allow the generated
code to properly convert an on-the-wire integer representation
of an enum value to the corresponding enum constant.

<h2><u>Compiling the Generated Code</u></h2>
Note that the file ast.jar contains both the compiler and the runtime system.
Assume that the file ast.jar was installed in the directory /usr/local/lib.
Assume that our main program is <i>Test.java</i> with package "test".
Then compile X.java using some variant of this command.
<pre>
    javac -classpath ".;/usr/local/lib/ast.jar" Test.java X.java
</pre>
Then execute using some variant of this command.
<pr>
    java -cp ".;/usr/local/lib/ast.jar" test.Test
</pre>

<h2><u>Using the Generated Code</u></h2>
In order to use the generated code, it is necessary to create
an instance of <a href="#ast_runtime"><i>unidata.ast.runtime.ASTRuntime</i></a>.
Before describing this class, it is important to understand
the class <i>unidata.ast.runtime.AbstractIO</I>, which defines the
object used to serialize or deserialize data.

<h3>AbstractIO</h3>
This class contains an instance of
<i>java.io.InputStream</i>
for de-serialization
or an instance of 
<i>java.io.OutputStream</i>
for serialization
<p>
The stream to be used is determined by the
direction, which in turn is determined by the mode
of enum type <i>unidata.ast.runtime.AbstractIO.IOmode</i>.
<p>
<i>AbstractIO</i> defines a set of methods.
<ul>
<li> <i>public void write(int len, byte[] buffer) throws IOException</i>&nbsp;&mdash&nbsp;
     write len bytes of data from buffer into the OutputStream object
     (mode must be IOmode.Ast_write).
<li> <i>public boolean read(int len, byte[] buffer) throws IOException</i>&nbsp;&mdash&nbsp;
     read len bytes of data from the InputStream object into buffer
     (mode must be IOmode.Ast_read).
     if less than len bytes are available, return false, otherwise true.
</ul>
In addition, <i>AbstractIO</i> contains setters and getters
for the mode, the input stream, and the outputstream.
<p>
Note that users will rarely call these operators; rather, they are
used by internally by <i>ASTRuntime</i>.
<p>
The runtime system provides one implementation
of <i>AbstractIO</i>, namely
<i>ByteIO</i>. This class reads and writes to byte arrays (byte[]).
If no outputstream is specified, then the default is an instance of
<i>java.io.ByteArrayOutputStream</i>.

<h3>ASTRuntime Creation</h3>
The primary <i>ASTRuntime</i> constructor takes
an <i>AbstractIO</i> instance as its argument.
<p>
The class constructor for the generated message classes
expect an instance of the runtime object
as the argument.

<h3>Miscellaneous Methods</h3>
<i>ASTRuntime</i> also has a number of other methods.
A setter and getter are provided to access the <i>AbstractIO</i> object.
<p>
A <i>close()</i> method is provided to reclaim resources.
<p>
A number of methods are provided to
support, primarily, the reading and writing
of primitive typed fields. As a rule, the user
will not call these methods, but understanding them
is useful when trying to understand the generated code.
These method prototypes are as follows.
<dl>
<dt> <i>void write(int len, byte[] buffer) throws IOException</i>
<dd>
Wraps <i>AbstractIO.write</i>.
<dt> <i>boolean read(int len, byte[] buffer) throws IOException</i>
<dd>
Wraps <i>AbstractIO.read</i>.
</dd>
<p>
<dt><i>void skip_field(int wiretype, int fieldno) throws IOException</i>
<dd> Skips an unknown field given the wiretype and fieldnumber.
<p>
<dt>
int getTagSize(Sort sort, int fieldno)
<dd>
Calculates the size of the tag for a given sort and fieldno.
The sort is used to determine the wiretype and then the
wiretype and fieldno determine the tag.
<p>
<dt>
void write_tag(int wiretype, int fieldno)
<dd>
Computes and writes the tag to the output stream.
<p>
<dt>
void read_tag(int[] wiretype, int[] fieldno) throws IOException
<dd>
Extracts the tag from the input stream,
decomposes it into wiretype and field number
and returns them. In effect the arguments
serve as the equivalent of call by reference (e.g. "int*" in C).
<p>
<dt>
void write_size(int size) throws IOException
<dd>
Writes a size value as a 32 bit varint to the output stream.
<p>
<dt>
int read_size() throws IOException
<dd>
Reads a 32 bit varint from the input stream and returns it.
<p>
<dt>
int readvarint(byte[] buffer) throws IOException
<dd>
Reads the bytes constituting a varint
from the input stream and places them in the buffer.
Returns the number of bytes read.
<dt>
int readandcount(int wiretype, byte[] buffer)
throws IOException
<dd>
<ul>
<li>If the wiretype is <i>Ast_varint</i>
then call <i>readvarint()</i>
and return its value.
<p>
<li>If the wiretype is <i>Ast_32bit</i>
then read 4 bytes into the buffer
and return the value 4.
<p>
<li>If the wiretype is <i>Ast_64bit</i>
then read 8 bytes into the buffer
and return the value 8.
<p>
<li>If the wiretype is <i>Ast_counted</i>
then read the varint into the buffer
and decode it into a integer representing the size.
Return the decoded value.
</dl>

<h2><u>Example</u></h2>
<h3>Example 1</h3>
This example shows a method that takes as input
a pointer to a message object (of type "Msg"). It encodes
the message and then decodes the resulting byteio stream.
It then invokes a user define method to compare the two
instances for equality.
<pre>
static int
test(Msg* msg)
{
    int status = AST_NOERR;
    ASTRuntime* rt;
    bytes_t encoded;
    Msg* decodedmsg = NULL;

    /* Create an expandable byteio stream into which
       msg will be encoded.
    */

    /* Note the use of NULL buffer and 0 length */
    /* This function creates an ASTRuntime instance
       and returns a pointer in the last argument.
    */
    status = ast_byteio_new(AST_WRITE,NULL,0,&rt);
    if(status != AST_NOERR) goto fail;

    /* Write the msg object into the runtime buffer */
    status = Msg_write(rt,msg);
    if(status != AST_NOERR) goto fail;

    /* Extract the contents of the stream */
    status = ast_byteio_content(rt, &encoded);
    if(status != AST_NOERR) goto fail;
        
    /* Reclaim the ASTRuntime object */
    status = ast_reclaim(rt);
    if(status != AST_NOERR) goto fail;

    /* Create byteio stream backed by the bytes
       from the encode process.
    */

    status = ast_byteio_new(AST_READ,encoded.bytes,encoded.nbytes,&rt);
    if(status != AST_NOERR) goto fail;

    /* Decode a Msg instance; not the use of the Msg** in last argument */
    decodedmsg = NULL;
    status = Msg_read(rt,&decodedmsg);
    if(status != AST_NOERR) goto fail;

    status = ast_reclaim(rt);
    if(status != AST_NOERR) goto fail;

    /* Compare using an assumed user-defined compare function*/
    if(!compare(msg,decodedmsg)) {
        fprintf(stderr,"*** FAIL: content mismatch\n");
        status = AST_EFAIL;
        goto fail;
    }

    fprintf(stderr,"*** PASS: %s\n",testname);
    return status;

fail:
    fprintf(stderr,"*** FAIL: %s  status=%d\n",testname,status);
    return status;
}
</pre>


<h2><u>Change Log</u></h2>
<ol>
<li>07/03/2010 - First draft.
</ol>

</body
</html>

