<!-- Copyright 2011, UCAR/Unidata  -->
<!-- See the LICENSE.txt file for more information. -->
<html>
<body>
<center>

<h1>Unidata AST Translation System<br>
User Manual</h1>
<h3>Draft: 07/03/2011<br>
Last Revised: 07/03/2011</h3>
<h3>Author: Dennis Heimbigner<br>
dmh@ucar.edu<br>
Unidata<br>
Copyright 2011, UCAR/Unidata.</h3>
</center>

<h2><u>Introduction</u></h2>
This document describes how to use the
C code generated by the Unidata AST compiler.
The detailed man page for the compiler is in the file
<i>astman.html</i> and should be consulted before reading
this document.

<h2><u>Compiler Output</u></h2>
Given a protobuf file name
<i>X.proto</i>
the ast compiler will generate the C code files 
<i>X.h</i>
and
<i>X.c</i>.
<p>
The ".h" file will contain a C structure for every message
declaration in the ".proto" file and an enumeration for every
enumeration declaration in the ".proto" file.
In addition, and for every message declaration,
<i>message M {...}</i> for example,
the ".h" file will define prototypes for procedures
to serialize an instance of a message M,
to deserialize an instance of a message M,
to reclaim (free) an instance of a message M,
and
to compute the run-time size of an instance of a message M.
<p>
<h3>Example</h3>
Assume we have the following message declaration.
<pre>
message Msg {
    required float field1 = 1;
    optional uint64 field2 = 2;
    repeated int32 field3 = 3;
}
</pre>
This will generate the following C structure.
<pre>
struct Msg {
    float field1;
    struct {int defined; uint64 value;} field2;
    struct {size_t count; int32* values;} field3;
};
</pre>
It will also generate the following four procedure prototypes.
<ul>
<li>extern ast_err Msg_write(ast_runtime*,Msg*);
<li>extern ast_err Msg_read(ast_runtime*,Msg**);
<li>extern ast_err Msg_reclaim(ast_runtime*,Msg*);
<li>extern size_t  Msg_get_size(ast_runtime*,Msg*);
</ul>
<p>
Note that the <i>Msg_read</i> function has
<i>Msg**</i>
instead of <i>Msg*</i> as its last argument.
This is because <i>Msg_read</i> will allocate an
instance of <i>Msg</i> and return a pointer to it
in its last argument.
<p>
The size procedure is necessary because the actual size
of each <i>Msg</i> object may vary at run-time.
<p>
Protobuf enumeration declarations are also translated in the
more or less obvious way. So given the protobuf enumeration
<pre>
enum Testenum {
    ECON1 = 1;
    ECON2 = 2;
    ECON3 = 3;
    ECON4 = 4;
    ECON5 = 5;
    ECON6 = 6;
}
</pre>
it will be translated to the following C enumeration declaration.
<pre>
typedef enum Testenum {
    ECON1=1,
    ECON2=2,
    ECON3=3,
    ECON4=4,
    ECON5=5,
    ECON6=6
} Testenum;
</pre>

<h2><u>Compiling the Generated Code</u></h2>
Assume that the system was installed in the directory /usr/local,
then invoke (e.g.) gcc to compile and load XXX.c using this command.
<pre>
    gcc -o main.exe main.c XXX.c -L/usr/local/lib -last
</pre>

<h2><u>Using the Generated Code</u></h2>
In order to use the generated code, it is necessary to create
an instance of <a href="#ast_runtime"><i>ast_runtime</i></a>.
This instance provides the following
resources (see <i>ast_runtime.h</i>).
<ul>
<li> A data stream into which an arbitrary message can be serialized
or from which an arbitrary message can be de-serialized. The direction
of the stream is determined by the value of the <i>iomode</i> flag
in the <i>ast_runtime</i> instance.
The state of the stream is encoded as
an opaque pointer to data called <i>stream</i>.
<p>
<li> A table of operators to perform the following functions.
    <ul>
    <li> <i>write</i>&nbsp;&mdash&nbsp;
	 write N bytes of data from memory into the stream object.
    <li> <i>read</i>&nbsp;&mdash&nbsp;
	 read N bytes of data from the stream object into memory;
	 if less than N bytes are available, return an EOF error.
    <li> <i>mark</i>&nbsp;&mdash&nbsp;
	 mark the input stream so that attempts to read past the mark
         will generate an EOF. Marks may be nested.	
    <li> <i>unmark</i>&nbsp;&mdash&nbsp;
	 pop the current mark, if any, and return to the previous mark.
    <li> <i>alloc</i>&nbsp;&mdash&nbsp;
	 allocate N bytes of memory.
    <li> <i>free</i>&nbsp;&mdash&nbsp;
	 free memory allocated by the alloc() function.
    </ul>
    Note that users will rarely call these operators; rather, they are
    used by the generated code.
<p>
<li> An error flag to hold an error code.
</ul>

<h3>ast_runtime Creation</h3>
The creation of an <i>ast_runtime</i> instance
is controlled by stream-specific creation procedures.
The ast code base comes with one such stream, namely
<i>ast_byteio</i> (see <i>ast_byteio.h</i>).
This implements a stream based on
reading and writing from an in-memory buffer.
The prototype create function is as follows.
<pre>
extern ast_err ast_byteio_new(ast_iomode mode,void* buf,size_t len,ast_runtime**);
</pre>
<p>
An <i>ast_runtime</i> instance is created
and a pointer to it is returned in the last argument.
<p>
If the mode is 
<i>AST_READ</i>, then
the stream reads from the specified buffer
with a given length.
<p>
If the mode is 
<i>AST_WRITE</i>, then
the buffer and len arguments
are ignored and an internal buffer
is created that will grow in length as writing
occurs.
Two procedures are provided to obtain the
buffer and its length.
<pre>
extern ast_err ast_byteio_count(ast_runtime*, size_t*);
extern ast_err ast_byteio_content(ast_runtime*, bytes_t*);
</pre>

<h3>Miscellaneous Procedures</h3>
A number of procedures are provided to
support, primarily, the reading and writing
of primitive typed fields. As a rule, the user
will not call these procedures, but understanding them
is useful when trying to understand the generated code.
These procedure prototypes are as follows.
<dl>
<dt>extern ast_err ast_read_primitive(ast_runtime*, const ast_sort, const int fieldno, void* val);</dt>
<dd>
Read a single primitive value from the input stream. The second argument
(of type <i>ast_sort</i>) specifies the type of the item to be read.
The last field specifies memory into which the value is placed.
</dd>
<p>
<dt>extern ast_err ast_write_primitive(ast_runtime*, const ast_sort, const int fieldno, const void* val);</dt>
<dd>
Write a single primitive value into the output stream. The second argument
(of type <i>ast_sort</i>) specifies the type of the item to be read.
The last field specifies memory from which the value is taken.
</dd>
<p>
<dt>extern ast_err ast_read_enum(ast_runtime*, const ast_sort, const int fieldno, void* val);</dt>
<dd>
Read a single enumeration value.
</dd>
<p>

<dt>extern ast_err ast_read_primitive_packed(ast_runtime*, const ast_sort, const int fieldno, void* val);</dt>
<dd>
Read a single packed primitive value.
</dd>
<p>
<dt>extern ast_err ast_write_primitive_packed(ast_runtime*, const ast_sort, const int fieldno, const void* val);</dt>
<dd>
Write a single packed primitive value.
</dd>
<p>
<dt>extern ast_err ast_repeat_append(ast_runtime*,ast_sort,void*,void*);</dt>
<dd>
Extend a repeated field and append the specified value to it.
</dd>
<p>
<dt>extern ast_err ast_write_tag(ast_runtime*, const unsigned int, const unsigned int);</dt>
<dd>
Write out a tag value.
</dd>
<p>
<dt>extern ast_err ast_write_size(ast_runtime*, const size_t);</dt>
<dd>
Write out a size value.
</dd>
<p>
<dt>extern ast_err ast_read_tag(ast_runtime* rt, int* wiretypep, int* fieldnop);</dt>
<dd>
Read a tag value and break it into a wiretype
and field number and return those.
</dd>
<p>
<dt>extern ast_err ast_read_size(ast_runtime*, size_t*);</dt>
<dd>
Read a size value.
</dd>
<p>
<dt>extern ast_err ast_skip_field(ast_runtime* rt, int wiretype, int fieldno);</dt>
<dd>
Skip an arbitrary typed field.
is unknown.
</dd>
<p>

<dt>extern ast_err ast_reclaim(ast_runtime* rt);</dt>
<dd>
Reclaim (free) a <i>ast_runtime</i> instance.
This has <i>ast_close</i> as an alias.
</dd>
<p>

<dt>extern ast_err ast_reclaim_string(ast_runtime* rt, char* value);</dt>
<dd>
Reclaim an allocated string.
</dd>
<p>
<dt>extern ast_err ast_reclaim_bytes(ast_runtime* rt, bytes_t* value);</dt>
<dd>
Reclaim an allocated byte string.
</dd>
<p>

<dt>extern size_t ast_get_tagsize(ast_runtime*,ast_sort,int);</dt>
<dd>
Calculate the on-the-wire size of tag.
</dd>
<p>

<dt>extern size_t ast_get_size(ast_runtime*, ast_sort, void*);</dt>
<dd>
Calulate the on-the-wire size of a primitive value.
</dd>
<p>
</dl>

<h2><u>Example</u></h2>
<h3>Example 1</h3>
This example shows a procedure that takes as input
a pointer to a message object (of type "Msg"). It encodes
the message and then decodes the resulting byteio stream.
It then invokes a user define procedure to compare the two
instances for equality.
<pre>
static int
test(Msg* msg)
{
    int status = AST_NOERR;
    ast_runtime* rt;
    bytes_t encoded;
    Msg* decodedmsg = NULL;

    /* Create an expandable byteio stream into which
       msg will be encoded.
    */

    /* Note the use of NULL buffer and 0 length */
    /* This function creates an ast_runtime instance
       and returns a pointer in the last argument.
    */
    status = ast_byteio_new(AST_WRITE,NULL,0,&rt);
    if(status != AST_NOERR) goto fail;

    /* Write the msg object into the runtime buffer */
    status = Msg_write(rt,msg);
    if(status != AST_NOERR) goto fail;

    /* Extract the contents of the stream */
    status = ast_byteio_content(rt, &encoded);
    if(status != AST_NOERR) goto fail;
        
    /* Reclaim the ast_runtime object */
    status = ast_reclaim(rt);
    if(status != AST_NOERR) goto fail;

    /* Create byteio stream backed by the bytes
       from the encode process.
    */

    status = ast_byteio_new(AST_READ,encoded.bytes,encoded.nbytes,&rt);
    if(status != AST_NOERR) goto fail;

    /* Decode a Msg instance; not the use of the Msg** in last argument */
    decodedmsg = NULL;
    status = Msg_read(rt,&decodedmsg);
    if(status != AST_NOERR) goto fail;

    status = ast_reclaim(rt);
    if(status != AST_NOERR) goto fail;

    /* Compare using an assumed user-defined compare function*/
    if(!compare(msg,decodedmsg)) {
        fprintf(stderr,"*** FAIL: content mismatch\n");
        status = AST_EFAIL;
        goto fail;
    }

    fprintf(stderr,"*** PASS: %s\n",testname);
    return status;

fail:
    fprintf(stderr,"*** FAIL: %s  status=%d\n",testname,status);
    return status;
}
</pre>


<h2><u>Change Log</u></h2>
<ol>
<li>07/03/2010 - First draft.
</ol>

</body
</html>

